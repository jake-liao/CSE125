Jake Liao, Mark Zakharov
Lab 1
4-15-20

PART 1.

The Linear Feedback Shift Register (LFSR) is a series connection of flip flops, some of which are interconnected with XOR gates. The output of each flip flop is read serially to provide a pseudorandom binary integet. This pseudorandomness comes from the XOR gates changing some of the bits of what would otherwise be a rotating byte. Liao designed the structural module of the LFSR, using eight flip flops along side an 8-bit 2 to 1 multiplexor to control whether each flip flop would recieve its upcoming signal from the previous flip flop or from user inputted data. The multiplexor input was an active low reset signal, an asynchronous input from the user. With all input and output signals contrained to a delay of 2 ns and a clock set to 100 MHz (10 ns period), the design was synthesised to check the possible slack. The worst negative slack shown in vivado actually represents greatest possible speed up of the design, this means the maximum frequency Fmax could be increased without risk of delay.Since the greatest delay (WNS) for this design came out to be 2.716 ns and the set clock period was 10 ns, Fmax can be calculated with (1/(T-WNS))=(1/(10-2.716))= 137 MHz. The Resource Utilization report of the Vivado Synthesis states the design used 5 LUTs and 8 FFs, which is expected using a structural design where 8 FFs were individually instantiated. 

Zakharov designed the behavioral module of the LFSR, using a positive edge clock driven always block. The logic contained was an if/else statement, where if the reset signal was set low then the flip flops would be set to the inputted data in parallel, otherwise the flip flops (which are the output registers) swap values with the flip flop before them, except for three who XOR their signal and the last flip flops signal. Just like in the structural module, the in/out delay was set to 2 ns and the clock period was 10 ns in the constraints. The WNS came out to be 2.092, less than the structural model indicating a more complex (and less efficient) synthesized model. The Fmax came out to be 126 Mhz, 11 MHz less than the structural model. The Resource report shows that 27 LUTs and 24 FFs were generated in the design, which may explain why this design ran slower than its structural counterpart. In the always block the 8 output registers were mentioned 3 times, once when loading data_in and twice to swap each registers value with the previous one. This implementation may have created a holding and recieving register for each "middle" register, thereby having 3 per held value and 24 total. Nevertheless, both modules came out to the same end result, the first 10 values of which are: 0xA5, 0x57, 0xAE, 0x41, 0x82, 0x19, 0x32, 0x64, 0xC8, 0x8D.

PART 2.

The simplest way to build a multiplier is through an accumulator, a hardware block that incrementally adds to its stored value. By setting argument 1 of the multiplicative operation to a counter that makes the accumulator add argument 2 each time the counter counts simulated multiplication. Such a design was set up by Liao in the form of a case statement state machine, which switched between an initial state where all held values and in/out were set to zero waiting for a start signal. The next state had an incrementing counter that had a conditional waiting for the counter to be equal to the argument value it was counting to. Once the counter was equal to its desirer value, the final state was reached, setting the done signal high and stabilizing the resulting value. The simulation ran on the mulitplied module shows that it took it 455 ns to reach the desied result of 67*43, approximately 45 clock cycles of the constrained 10 ns clock period. This is correct as 43 was used as the counter value and 1 clock cycle was used to initialize the FFs and 1 was used to recognize the counter had completed. Using 2 ns delay for each in/out the WNS came out to be 2.716 ns which results in a 137 MHz Fmax. The resources used list 63 LUTs and 67 FFs, this may be a result of the product output being a 32 bit register and being added to itself using the accumulator required two of them, taking up 64 FFs with the other 3 FFs being the done signal and the 2-bit state machine. 

The quadruple accumulator module was built by Zakharov, taking the skeleton of the simple multiplier model and modifying the conditionals of the second state. 

